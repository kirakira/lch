\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{epstopdf}
\usepackage{amssymb,amsmath}
\usepackage{amsthm}
%\usepackage{subfigure}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[]{algorithm2e}
\usepackage{xcolor,listings}
\usepackage{multirow}
\usepackage{hyperref}

\title{LCH: A Reliable Distributed Source Code Version Control System}
\author{Shike Mei, Menghui Wang, and Lichao Yin}

\begin{document}
\maketitle

\abstract{
    Today popular source code version control systems do not replicate data for reliability.
    We share our experience in building LCH (abbreviated from Launch), a reliable source code version control system.
    LCH replicates data on multiple servers and uses the Paxos\ref{paxos} protocol along with an update log to provide strong consistency to clients.
    With a three-step catch-up mode, LCH can also recover from failures seamlessly.
    Our test results show LCH is a reliable version control system.
}

\section{Introduction}

A version control system is a system that keeps track of multiple history versions of every managed document, and allows a user to checkout or revert to previous versions as needed.
Version control systems usually allow for a group of people contributing to one project.
Today version control systems have an extensive use in source code management, collaborative editing, data backup, etc.

Due to different applications, a version control system can differ from another in many aspects.
\begin{itemize}
    \item History granularity: linear versus directed acyclic graph (DAG).
        Examples include: Google Docs (linear), Subversion (linear), git (DAG), Mercurial (DAG).
    \item Implicit checkpointing versus explicit checkpointing.
        An implicit checkpointing system will automatically save the state of the current document whenever the system thinks appropriate, while an explicit checkpointing system will not do so until instructed by the user.
        Examples include: Google Docs (implicit), Dropbox (implicit), git (explicit), Subversion (explicit).
    \item Conflict Resolution.
        A conflict is when multiple versions of a same file (or a same line of a same file) are found at the same time.
        Conflicts could result from out-of-date repository, conflicting edits from different sources, network delays, or system faults.
        Some systems will resolve conflicts automatically based on some metrics or mechanisms.
        Some examples include conflict resolution by timestamp (Google Contacts), vector clocks.
        Other systems will need human intervention to resolve conflicts (Dropbox, git, Subversion, CVS).
    \item Failure model.
        Some systems have a centralized server and thus are vulnerable to single-node failures (Subversion, CVS, git, Mercurial\footnotemark),
        while others will store data reliably on a distributed set of servers (Google Docs).
        \footnotetext{
        Although git and Mercurial are capable of storing data on multiple servers, replication is not supported natively and users will need to push data to every single place manually.
        Moreover, since atomicity is not provided when doing so, it may will cause complex consistency issues.
    For this reason, most git and Mercurial users will use git and Mercurial in the same way as they use Subversion: designate a central server to store all the data.}
    \item Offline edits.
        Some systems allow making modifications while offline (git, Dropbox) while others do not (Subversion, Google Docs).
\end{itemize}

Replication is the key to reliability.
However from the list above one can see that today few version control systems replicate data.
This motivates our project.
Simply speaking, LCH is a version control system that will store source code reliably on a distributed set of servers.
Source code is different from other application in that it needs to be precise at any time.
Thus strong consistency needs to be preserved while replicating data.
We will share our experience in how to use the Paxos\ref{paxos} protocol to help us achieve this end.

In the rest of this paper we discuss the various trade-offs in when we design LCH, and we share our experience in implementing it.
It is organized as follows: in Section~\ref{sec:design}, we discuss our reasonings and considerations behind the various decisions we made in designing LCH.
Section~\ref{sec:impl} will mainly focus on implementation details of the server and the client, including how we incorporate the Paxos protocol in our system and some improvements of it.
Section~\ref{sec:eval} will state our methodology in evaluating our system.
Section~\ref{sec:conclusion} concludes our project.


\section{Design}
\label{sec:design}
\subsection{Linear History}
\subsection{Explicit Checkpointing}
\subsection{Full Replication}
\subsection{Consistency and Conflict Resolution}
\subsection{Fault-Tolerant}
\subsection{Online Edits}
\subsection{A Typical Workflow}

\section{Implementation}
\label{sec:impl}
\subsection{Paxos and Update Log}
\subsection{Catch-up Mode}
\subsection{Random Backoff}
\subsection{Client}

LCH provides users with a simple interface to maintain a \emph{linear} version history. Each version is called a commit, and an integer version number is associated with every commit. LCH provides two commands to work with: sync and commit. 
\begin{itemize}
  \item sync: pull changes from the server since the last commit in the local workset, and write those changes to corresponding local files. If a conflict is detected (both remote and local change the same place), user will be directed to resolve the conflict.
  \item commit: push local changes to the server as a new commit. The commit will be accepted if and only if the local version it is based on is up to date (i.e., last local commit matches the most recent commit on the server). If the commit is rejected, the user will be prompted to run a synccommand first.

\end{itemize}
A typical work flow of the client is as belows.
\begin{itemize}
  \item Initialization
  \item Make local changes
  \item sync
  \item Resolve conflicts
  \item commit
  \item Accepted? If yes, goto make local change; if no, goto sync
\end{itemize}

We note implementation details: First, when initialize the client, we need to set the directory for local copy and the path for metadata file. The metadata file stores the version information of latest sync from the server. Second, when doing sync, we first randomly ask a server to get the metadata and all changed information since the last sync version. Then, we compare the local changes on the last sync version and the changes of the latest version, if the two changes are different, we report a conflict file. For each conflict file, we update the file to latest server version, but make the copy the local changed version and warn user to resolve the conflict. Third, when doing commit, the client will first randomly ask a server the latest version, only when the versions are the same the commit can proceed. Send all changed files to the server, once the server returns ``successfully committed'', the client update the metadata file.

\section{Evaluation}
\label{sec:eval}
\subsection{Consistency Test}
\subsection{Reliability Test}
\subsection{Throughput Test}

\section{Conclusion}
\label{sec:conclusion}


\section{References}

[1] Lamport, L. (2001). Paxos made simple. ACM Sigact News, 32(4), 18-25.

[2] Chandra, T. D., Griesemer, R., \& Redstone, J. (2007, August). Paxos made live: an engineering perspective. In Proceedings of the twenty-sixth annual ACM symposium on Principles of distributed computing (pp. 398-407). ACM.

\end{document}
