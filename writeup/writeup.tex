\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{epstopdf}
\usepackage{amssymb,amsmath}
\usepackage{amsthm}
%\usepackage{subfigure}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[]{algorithm2e}
\usepackage{xcolor,listings}
\usepackage{multirow}
\usepackage{hyperref}

\title{LCH: A Reliable Distributed Source Code Version Control System}
\author{Shike Mei, Menghui Wang, and Lichao Yin}

\begin{document}
\maketitle

\abstract{
    Today popular source code version control systems do not replicate data for reliability.
    We share our experience in building LCH (abbreviated from Launch), a reliable source code version control system.
    LCH replicates data on multiple servers and uses the Paxos\ref{paxos} protocol along with an update log to provide strong consistency to clients.
    With a three-step catch-up mode, LCH can also recover from failures seamlessly.
    Our test results show LCH is a reliable version control system.
}

\section{Introduction}

A version control system is a system that keeps track of multiple history versions of every managed document, and allows a user to checkout or revert to previous versions as needed.
Version control systems usually allow for a group of people contributing to one project.
Today version control systems have an extensive use in source code management, collaborative editing, data backup, etc.

Due to different applications, a version control system can differ from another in many aspects.
\begin{itemize}
    \item History granularity: linear versus directed acyclic graph (DAG).
        Examples include: Google Docs (linear), Subversion (linear), git (DAG), Mercurial (DAG).
    \item Implicit checkpointing versus explicit checkpointing.
        An implicit checkpointing system will automatically save the state of the current document whenever the system thinks appropriate, while an explicit checkpointing system will not do so until instructed by the user.
        Examples include: Google Docs (implicit), Dropbox (implicit), git (explicit), Subversion (explicit).
    \item Conflict Resolution.
        A conflict is when multiple versions of a same file (or a same line of a same file) are found at the same time.
        Conflicts could result from out-of-date repository, conflicting edits from different sources, network delays, or system faults.
        Some systems will resolve conflicts automatically based on some metrics or mechanisms.
        Some examples include conflict resolution by timestamp (Google Contacts), vector clocks.
        Other systems will need human intervention to resolve conflicts (Dropbox, git, Subversion, CVS).
    \item Failure model.
        Some systems have a centralized server and thus are vulnerable to single-node failures (Subversion, CVS, git, Mercurial\footnotemark),
        while others will store data reliably on a distributed set of servers (Google Docs).
        \footnotetext{
        Although git and Mercurial are capable of storing data on multiple servers, replication is not supported natively and users will need to push data to every single place manually.
        Moreover, since atomicity is not provided when doing so, it may will cause complex consistency issues.
    For this reason, most git and Mercurial users will use git and Mercurial in the same way as they use Subversion: designate a central server to store all the data.}
    \item Offline edits.
        Some systems allow making modifications while offline (git, Dropbox) while others do not (Subversion, Google Docs).
\end{itemize}

Replication is the key to reliability.
However from the list above one can see that today few version control systems replicate data.
This motivates our project.
Simply speaking, LCH is a version control system that will store source code reliably on a distributed set of servers.
Source code is different from other application in that it needs to be precise at any time.
Thus strong consistency needs to be preserved while replicating data.
Paxos\ref{paxos} is a protocol that solves the consensus problem in a distributed system.
With the help of an update log, we can build a strongly consistent distributed system that replicates data across many servers.

LCH is designed to tolerate failures.
When a failed server is restarted, it will first operate in a 3-step catch-up mode.
Unlike the catch-up mode proposed by Google \ref{paxos2}, we add an additional third step that will make sure everything missed out is collected.
The catch-up mode will be discussed in detail in Section~\ref{sec:impl}.

In the original protocol, it is possible that Paxos rounds keep failing because multiple proposers make conflicting proposes in an alternating way.
We propose random backoff to mitigate this issue.
In our solution, when such scenario is detected, a proposer will, with a certain probability, try to postpone its proposal for a random period of time, so as to minimize the likelihood that more than one proposers propose at the same time.

In the rest of this paper we discuss the various trade-offs in when we design LCH, and we share our experience in implementing it.
It is organized as follows: in Section~\ref{sec:design}, we discuss our reasonings and considerations behind the various decisions we made in designing LCH.
Section~\ref{sec:impl} will mainly focus on implementation details of the server and the client, including how we incorporate the Paxos protocol in our system and some improvements of it.
Section~\ref{sec:eval} will state our methodology in evaluating our system.
Section~\ref{sec:conclusion} concludes our project.


\section{Design}
\label{sec:design}
In this section we will discuss the design of LCH, as well as our reasonings behind every decision.

\subsection{System Overview}
LCH is a client-server application.
Unlike a traditional version control system, user data is replicated on multiple LCH servers for reliability.
Figure~\ref{fig:1} shows a typical topology structure of LCH.

\subsection{Client Design}
LCH uses similar terminologies and concepts as were used in other version control systems.
A version is a state consisting of the states of all managed files.
Changes made to a version are called a commit, and a commit will lead to a new version.
LCH provides linear version history, which means commits can only be made to the latest version.
As a consequence, every version is associated with a single integral number, beginning from $0$, which is the version for an empty repository.
It is worth noting that although we choose to implement LCH using linear version history, DAG version history can also be achieved under our design.
We choose to use linear version history because it provides a cleaner and more understandable interface to the user, and it is less likely for misoperations to happen.
Though a DAG-based history is more powerful and flexible, it is also harder to implement and we choose not to spend our efforts on it.

The client offers two simple commands, \texttt{sync} and \texttt{commit}.
\texttt{sync} will pull from a server recent changes from the current version of the client, and then the client will apply all those changes.
A \emph{conflict} may happen when both remote and local changes are made to the same file.


LCH is a distributed system.
Multiple servers can serve their own clients in the same time.
Every client can choose to connect to any LCH server, and servers will handle replication and consistency behind the scene.
Client will feel like there is only one server there.
That being said, when the server a client is connecting to is not responding, the client can choose to connect to any other server.
In contrast to our distributed design, an alternative is to use a master-slave scheme.
Although the master-slave scheme handles consistency issues more easily, it is less reliable than our distributed structure.
For example, when a master failure is monitored, a master flip must be done.
During the flip, there is a short period of time that the system is not available.
Moreover, a master failure may also cause data loss.

\subsection{Linear History}
\subsection{Explicit Checkpointing}
\subsection{Full Replication}
Every LCH server is identical and equally capable.
This means, every LCH server will store a whole database of all history commits.
We did not choose to partition data for the following reasons:
\begin{itemize}
    \item Full replication provides higher read throughput than partitioning does.
        In our current design, every server is able to serve read requests clients in parallel
        If we partition our data
    \item
\end{itemize}

\subsection{Consistency and Conflict Resolution}
\subsection{Fault-Tolerant}
\subsection{Online Edits}
\subsection{A Typical Workflow}

\section{Implementation}
\label{sec:impl}
\subsection{Paxos and Update Log}
\subsection{Catch-up Mode}
\subsection{Random Backoff}
\subsection{Client}

LCH provides users with a simple interface to maintain a \emph{linear} version history. Each version is called a commit, and an integer version number is associated with every commit. LCH provides two commands to work with: sync and commit. 
\begin{itemize}
  \item sync: pull changes from the server since the last commit in the local workset, and write those changes to corresponding local files. If a conflict is detected (both remote and local change the same place), user will be directed to resolve the conflict.
  \item commit: push local changes to the server as a new commit. The commit will be accepted if and only if the local version it is based on is up to date (i.e., last local commit matches the most recent commit on the server). If the commit is rejected, the user will be prompted to run a synccommand first.

\end{itemize}
A typical work flow of the client is as belows.
\begin{itemize}
  \item Initialization
  \item Make local changes
  \item sync
  \item Resolve conflicts
  \item commit
  \item Accepted? If yes, goto make local change; if no, goto sync
\end{itemize}

We note implementation details: First, when initialize the client, we need to set the directory for local copy and the path for metadata file. The metadata file stores the version information of latest sync from the server. Second, when doing sync, we first randomly ask a server to get the metadata and all changed information since the last sync version. Then, we compare the local changes on the last sync version and the changes of the latest version, if the two changes are different, we report a conflict file. For each conflict file, we update the file to latest server version, but make the copy the local changed version and warn user to resolve the conflict. Third, when doing commit, the client will first randomly ask a server the latest version, only when the versions are the same the commit can proceed. Send all changed files to the server, once the server returns ``successfully committed'', the client update the metadata file.

\section{Evaluation}
\label{sec:eval}
\subsection{Consistency Test}
\subsection{Reliability Test}
\subsection{Throughput Test}

\section{Conclusion}
\label{sec:conclusion}


\section{References}

[1] Lamport, L. (2001). Paxos made simple. ACM Sigact News, 32(4), 18-25.

[2] Chandra, T. D., Griesemer, R., \& Redstone, J. (2007, August). Paxos made live: an engineering perspective. In Proceedings of the twenty-sixth annual ACM symposium on Principles of distributed computing (pp. 398-407). ACM.

\end{document}
